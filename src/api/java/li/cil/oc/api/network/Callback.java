package li.cil.oc.api.network;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * This annotation can be used for methods in an {@link Environment} to mark
 * them for exposure to computers.
 * <p/>
 * Any method exposed like this can be enumerated and called from a computer
 * that can see the node of the environment.
 * <p/>
 * Note that methods annotated with this interface must have the following
 * signature:
 * <pre>
 *     Object[] f(Context context, Arguments arguments);
 * </pre>
 * <p/>
 * The method may return <tt>null</tt> in case it doesn't wish return anything,
 * which is functionally equivalent to returning an empty array.
 * <p/>
 * To raise an error from your callback, simply throw an exception. The
 * convention for Lua is to return (null, "reason") for 'soft' errors, i.e.
 * errors that are no fault of the caller. For example, passing invalid
 * arguments will generate an exception, requesting information and the lookup
 * of said information failing should not.
 *
 * @see li.cil.oc.api.network.Context
 * @see Arguments
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Callback {
    /**
     * The name under which to make the callback available.
     * <p/>
     * This defaults to the name of the annotated method if left empty.
     */
    String value() default "";

    /**
     * Whether this function may be called directly from the computer's executor
     * thread instead of from the server thread.
     * <p/>
     * You will have to ensure anything your callback does is thread safe when
     * setting this to <tt>true</tt>. Use this for minor lookups, for example.
     * This is mainly intended to allow functions to perform faster than when
     * called 'synchronously' (where the call takes at least one server tick).
     * <p/>
     * Keep in mind that the node {@link li.cil.oc.api.network.Network} is <em>not</em> thread safe!
     * Be sure you know what you're doing if you're working with a node's
     * network in a direct callback.
     */
    boolean direct() default false;

    /**
     * The maximum number of direct calls that may be performed on this
     * component in a single <em>tick</em>.
     * <p/>
     * This can be used to throttle call speed. For example, this is used by
     * graphics cards to limit the amount of net traffic can be generated by
     * updating the screen they are bound to.
     * <p/>
     * You should generally apply a limit if the callback allocates persisting
     * memory (i.e. memory that isn't freed once the call returns), sends
     * network messages, or uses any other kind of resource for which it'd be
     * bad if it were to be used from user programs in an unchecked, unregulated
     * manner.
     * <p/>
     * Note that the limit does <em>not</em> apply when the method is invoked
     * via a direct call to {@link Component#invoke(String, li.cil.oc.api.network.Context, Object...)}
     * from the host side. Also, this limit is per-computer, so the method may
     * be invoked more often than this per tick, if different computers call it.
     * <p/>
     * An exception to that rule is {@link Connector#changeBuffer(double)},
     * which is synchronized, so you can consume/produce power in direct calls.
     */
    int limit() default Integer.MAX_VALUE;

    /**
     * A documentation string that is made available to the computers the
     * component this callback belongs to is connected to. This allows for
     * ingame documentation of callbacks.
     * <p/>
     * You may want to give a short description of what a method does here, but
     * more importantly you should document the expected parameters and return
     * type here.
     * <p/>
     */
    String doc() default "";
}
